---
layout: post
title:  "2020牛客暑期多校训练营（第三场） 题解"
date:   2020-7-19 23:20:14
categories: nowcoder 题解
tags: 多校 牛客 数学 贪心 好题 构造 dp
---

* content
{:toc}

牛客多校，第三场。



---

> 若有公式图片无法正常显示，请使用梯子访问！

## E - Two Matchings

* 题意:  
*补这个题是真的难受，题意都给我看晕了。出题人老阅读理解了。*  
题意这样理解会比较好:  
有一索引序列P,并存在 x, y 索引，Px=y,Py=x;  
则有<img src="https://latex.codecogs.com/svg.latex?p_{p_x} = y;  p_{p_y} = x">（两层套娃，多想下）  
那么此时满足P是(x，y)索引的二元组。此时x，y索引在长度为2的数组a中的花费为：  
<img src="https://latex.codecogs.com/svg.latex?(|a_x-a_y|+|a_y-a_x|)/2%20=%20|a_x-a_y|">  
那么问题为：此时有一个序列由以上若干个a序列构成，构造出两个代表最小花费和次小花费的P序列,P序列要求:  
1. <img src="https://latex.codecogs.com/svg.latex?p_i \ne i">
2. <img src="https://latex.codecogs.com/svg.latex?p_p_i = i">
3. P 由 1, 2, 3... n 组成  
求这两个P序列在a中所得的最小与次小花费之和。

* 思路:  
 1. 最小值的情况:  假设a序列长度为4，且元素为{1,1,2,5}，那么此时满足花费最小的P序列为{2,1,4,3}.那么易得只需要将输入的a序列排序后按照P={2,1,4,3}计算花费，即可得最小花费。
 2. 次小值的情况:  依然是a={1,1,2,5},那么此时观察P序列，我们还能使用的P序列只有两种情况: P={3,4,1,2}; P={4,3,2,1}，这里以P={3,4,1,2}为例，画个图观察下P序列中次小值与最小值之间的关系:   
 ![P序列中的关系](https://github.com/FTLIKON/FTLIKON.github.io/blob/master/_posts/pic/2020-7-19-1.jpg?raw=true)  
 那么，由于a序列是一个排好序的序列, 如|a[3]-a[1]|=|a[3]-a[2]|+|a[2]-a[1]|,可得上图中的4个箭头可以转换为两条1->4的箭头，可得次小值为2*|a[4]-a[1]|。可以尝试下P={4,3,2,1}时，也是同样的结果。
 3. 当a序列的长度大于4时:  假设a序列长度为4时，同上推导依然是2*|a[6]-a[1]|; 当长度大于6时，则可以将这个P序列拆开来处理，因为4,6可以表示出所有偶数，例如8=4+4,10=4+6....
 4. 那么根据长度为4,6的两种情况，就可以列出了转移方程：  
 dp[i] = min(dp[i - 4] + v[i - 1] - v[i - 4], dp[i - 6] + v[i - 1] - v[i - 6]);  
 其中是截取上一步长度为4或6的情况来转移，根据当前位置的前4位或者前6位的最小值来进行转移。

*我发誓这是我博客里面写的最长的一个单题题解！！！累死了*

```c++

ll dp[200005];// long long

int main()
{
    IOS;
    int T;
    cin >> T;
    for (int ts = 0; ts < T; ++ts)
    {
        int n;
        cin >> n;
        vector<ll> v;
        for (int i = 0; i < n; ++i)
        {
            ll tmp;
            cin >> tmp;
            v.push_back(tmp);
        }
        sort(v.begin(), v.end());
        dp[0] = 0;
        dp[4] = v[3] - v[0];
        dp[6] = v[5] - v[0];
        dp[8] = v[7] - v[4] + dp[4];
        for (int i = 10; i <= n; i += 2)
            dp[i] = min(dp[i - 4] + v[i - 1] - v[i - 4], dp[i - 6] + v[i - 1] - v[i - 6]);
        cout << dp[n] * 2 << endl;//别忘了是两个箭头
    }
    return 0;
}

```

---
