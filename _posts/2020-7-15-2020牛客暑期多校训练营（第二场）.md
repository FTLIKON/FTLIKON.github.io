---
layout: post
title:  "2020牛客暑期多校训练营（第二场） 题解"
date:   2020-7-16 16:56:14
categories: nowcoder 题解
tags: 多校 牛客 数学 贪心 好题 构造
---

* content
{:toc}

牛客多校，第二场。



---


## A - All with Pairs

* 题意:  
给定n个字符串，每一个串前缀和其他串的后缀进行匹配，计算匹配的最大长度的平方和。


* 思路:  
把每个字符串的后缀都hash了存到map里，然后从每个字符串遍历，从前到后，第i个字符串的第j个点字符，我们得到前缀的hash值是x，ans[i][j]=mp[x],然后跑一遍next数组，求出ans[i][next[j]]-ans[i][j],这就是去重.

> 为什么要使用hash函数而不能直接将后缀存到map：因为直接存入字符串的话在进行匹配时时间复杂度相比数字匹配高很多，在此题会导致TLE。

> 去重的含义:  
  比如现在只有一个字符串ababa  
  从后往前存后缀  
  mp[a]=1;  
  mp[ba]=1;  
  mp[aba]=1;  
  mp[baba]=1;  
  mp[ababa]=1;  
  然后遍历前缀  
  ans[1]=mp[a]=1;  
  ans[2]=mp[ab]=0;  
  ans[3]=mp[aba]=1;  
  ans[4]=mp[abab]=0;  
  ans[5]=mp[ababa]=1;  
  然后从前往后  
  ans[next]-=ans[i]  
  最后就只有ans[5]=1了  
  


```c++



```

---

## B - Boundary

* 题意:  

给定n个点，让更多的点落在同一个经过原点（0，0）的圆上，求出最多的点数。


* 思路:  

根据三个点构成一个圆，即每次选取两个点，加上原点。然后根据这三个点推出该圆圆心的坐标，在存入map中，因为题目保证所有点的坐标不重复，那么圆心坐标相同的三点即在同一个圆上。  

根据三点求圆心的方法：画出另外两点与圆心直线的中垂线，两条中垂线的交点即为圆心。其中 (x1, y1) (x2, y2)为另外两点的坐标。可推得公式如下：

<img src="https://latex.codecogs.com/svg.latex?x = \frac{y_1({x_2^2}%20+%20{y_2^2})-y_2({x_1^2}%20+%20{y_1^2})}{y_1x_2-y_2x_1}">  

<img src="https://latex.codecogs.com/svg.latex?y = \frac{x_1(x_2^2+y_2^2)-x_2(x_1^2 + y_1^2)}{y_2x_1-x_2y_1}">

```c++

pair<int,int> a[2005];

map<pair<double,double>,int> p;

int main() 
{
	IOS;
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>a[i].first>>a[i].second;
	int ans=0;
	for(int i=0;i<n;i++)
	{
		/* 
		   开始时清空map，
		   因为假设 (a,b,0),(a,c,0) 圆心相同，
		   则一定有 (a,b,0),(a,c,0),(b,c,0) 圆心相同。
		*/
		p.clear();
		for(int j=i+1;j<n;j++)
		{
			double x1=a[i].first,y1=a[i].second,x2=a[j].first,y2=a[j].second;
			if(x1*y2==x2*y1) //除数不能为0 
			continue;
			//求出圆心坐标
			double x=(y1*(x2*x2+y2*y2)-y2*(x1*x1+y1*y1))/(y1*x2-y2*x1);
			double y=(x1*(x2*x2+y2*y2)-x2*(x1*x1+y1*y1))/(y2*x1-y1*x2);
			p[make_pair(x,y)]++;
			ans=max(ans,p[make_pair(x,y)]);
		}
	}
	cout<<ans+1;
	return 0;
}

``` 

---

## C - Cover the Tree

* 题意:  



* 思路:  



```c++



```

